# PostgreSQL内核学习笔记-1
`作者：小吴同学GOGOGO`

> 存储管理

- 在postgresql中，有专门的模块负责管理存储设备，包括内存和外存，我们称之为`存储管理器`。存储管理器提供了一组统一的管理内存和外存资源的功能模块，所有对内存和外村的操作都将交由存储管理器处理，可以认为存储管理器是数据库管理系统与物理存取设备的接口。
  
- 3.1 存储管理器的体系结构
  
  - postgresql的存储管理器的两个主要功能：内存管理和外存管理。除了管理内存和外存的交互外，存储管理器的另一个主要任务是对内存进行统筹安排和规划。
    
  - 内存管理：共享内存的管理+进程本地内存的管理
    
    - 共享内存管理：锁变量（为了防止多个进程并发访问共享内存中的数据时产生冲突，postgresql提供了轻量级锁，用于支持对共享内存中同一数据的互斥访问）、进程通信状态（使用共享内存实现了IPC）、缓冲区、存储控制器还提供了内存上下文（memoryContext）来用于统一管理内存的分配和回收。
      
    - 本地内存管理：每个后台进程专有，存储着属于该进程的cache, 事务管理信息，进程信息等。
      
  - 外存的管理：
    
    - 文件管理：在postgresql中，每个表都用一个文件（表文件）来存储，表文件以表的OID命名。从8.4版本开始，每个表除了表文件之外，还有两个附属文件：
      
      - VM；可见性映射表文件，加快清理操作（VACUUM）的执行速度
        
      - FSM：空闲空间映射表文件，用于表文件空闲空间的管理。
        
    - 空闲空间管理
      
    - 虚拟文件描述符管理
      
    - 大数据存储管理
      
  - 分页存储管理方式：
    
    - postgresql的存储管理器采用分页存储管理方式，数据在内存中以页面块的形式存在。
      
    - 每个`表文件`由多个BLCKSZ（一个可配置的常量）字节大小的`文件块`组成，每个文件块又可以包含多个`元组`;
      
    - 文件的写入以页面块为单位。postgresql的行式存储中，以元组为单位进行数据的存储。一个文件块有多个元组，但是元组不可以跨页面块存储。
      
  - 在内存中有缓冲区来存储这些文件块，大小固定为SLCKSZ,默认为8KB。
    
    - 进程共享的缓冲池：共享缓冲池
      
    - 进程私有的缓冲池：本地缓冲池
      
  - Cache机制：将进程最近使用的一些系统数据缓存在其私有内存中，其级别高于缓冲池。
    
  - 虚拟文件描述符：postgresql利用VFD（virtual file description） 来对物理文件进行管理，避免因为操作系统对进程打开文件数的限制而出现错误。
    
  - 空闲空间管理：用于快速定位到表文件中的空闲空间以便于插入新数据，从而提高空间利用率
    
  - IPC：进程间通信机制，postgresql是一个多进程的系统，IPC用来在多个后台进程之间进行通信和消息的传递。
    
  - 大数据存储管理：提供大对象和TOAST机制，大对象机制是一种由用户控制的大数据存储方法，允许用户调用函数，通过SQL语句直接向表中插入一个大尺寸文件（图片、视频、文档等）。TOAST机制则是在用户插入的变长数据超过一定限度时自动触发，用户无法对TOAST加以控制。
    
  - 一个postgresql进程从数据库读写一个元组的过程：`OID（Object id）`
    
    
  - 特别介绍：VFD机制：在磁盘管理器与物理文件之间还存在一层`虚拟文件描述符` VFD机制，这是为了防止进程打开的文件数目超过操作系统限制而引起不可预知的错误。磁盘管理器操作的是VFD，对于postgresql的进程来说，vfd的个数是无限的，即vfd机制通过合理的使用有限个实际文件描述符来满足无线的vfd访问需求。而在vfd管理模块，通过维持一个LRU池来管理实际文件描述符（FD）。由于系统允许的进程FD个数是有限的，因此当LRU池满时需要执行替换机制。
    
  - 写元组：在写入元组的时候，需要使用一定的策略找到一个具有合适空闲空间的缓冲块，然后将该元组装填到缓冲块中，系统会在适当的时候将这些被写入数据的缓冲块刷到存储介质中。对于单个进程而言，应尽量将连续插入的数据放在一个缓冲块中，因此在表的基本信息（RelationData）中记录了最近执行插入操作的缓冲块块号。如果其中有足够的空闲空间，就使用该缓冲块，否则就需要去寻找一个合适的文件块，将其读入内存并进行插入。显然，如果遍历所有的文件块查询其空闲空间，效率是很低的。为了加快查找的速度，在postgresql中，为每个表增加了一个附属文件（FSM:空闲空间映射表），用于记录每个表文件块的空闲空间大小，通过一定的查找机制和数据组织实现了文件块的快速选择。
    
  - 删除元组：采用`标记删除法` ，对元组作上删除标记，而非物理上删除元组。元组的物理清楚工作将由`VACUUM`机制来完成。在做VACUUM的时候去遍历所有文件块查找被删除的元组也是效率很低的，所以在版本8.4.1中同样为表设置了一个附属文件（可见性映射表（VM））来加快查找的速度。
    
- 3.2 外存管理
  
  外存管理负责处理数据库和外存介质（在postgresql中只实现了磁盘的管理操作）的交互过程。在postgresql中，外存管理由SMGR（主要代码在smgr.c中）提供对外存操作的统一接口。

  
- 3.2.1 表和元组的组织方式
  
  在postgresql中，同一个表中的元组按照创建顺序依次插入到表文件中，在进行清理操作来清除被删除的元组之后，元组也可以以无需的方式插入到具有空闲空间的文件块中。[元组之间不进行关联，这样的表文件称为堆文件]。postgresql中的四种堆文件：
  
   【1】普通堆：就是表文件（堆文件）
  
   【2】临时堆：与普通堆的结构相同，但临时堆仅在会话过程中临时拆创建，会话结束后会自动删除。
  
   【3】序列：元组值自动增长的特殊堆
  
   【4】TOAST表：也是一种普通堆，但是它被专门用于存储变长数据。
  
  以上四种堆功能不同，但是底层文件结构相似，每个堆文件都是由多个文件块组成。存储形式如下：
  
  
  堆文件具体描述：
  
  - PageHeaderData    -    长度为20B的页头数据，包含该文件块的一般信息，如：
    
    - 空闲空间的起始和结束位置
      
    - special space的开始位置
      
    - 项指针的开始位置
      
    - 标志信息，如是否存在空闲项指针，是否所有的元组都可见
      
  - Linp 是 ItemIdData类型的数组，每个ItemIdData结构用来指向文件块中的一个元组（见图3-4，Linp1指向tuple1, linp2指向tuple2）。而ItemIdData类型（4B）有属性：
    
    - lp_off: 元组在文件块中的偏移量
      
    - lp_flags: 该元组的长度
      
    - lp_len：元组的状态（未使用，正常使用,HOT重定向，死亡）
      
  - Freespace: 指未分配的空间（空闲空间），新插入页面中的元组及其对应的Linp元素都将从这部分空间空间中来分配，其中Linp元素从Freespace的开头开始分配，而新元组数据则从尾部开始分配。
    
  - Special space 是特殊空间，用于存放与索引方法相关的特定数据，不同的索引方法在special space 中存放不同的数据，由于索引文件的文件块结构和普通表文件的相同，因此special space在普通表文件块中并没有使用，其内容被置为空。
    
  - 元组信息：元组信息中除了存放元组的实际数据，还存放元组头部信息。该信息通过HeapTupleHeaderData结构描述，其中记录了操作此元组的事务ID和命令ID等信息，每个元组都有一个这样的头部信息。元组头部信息如下：
    
    
    字段解释：
    
    - t_choice:
      
      - t_heap: 用于记录对元组执行插入/删除操作的事务ID和命令ID。
        
      - t_datum：当一个新元组在内存中形成的时候，我们并不关心其事务可见性，因此在t_choice中只需要用DatumTupleFields结构来记录元组的长度等信息。但在把该元组插入到表文件时，需要在元组头信息中记录插入该元组的事务和命令ID，故此时会把t_choice所占用的额内存转换为HeapTypleFields结构并填入数据后再进行元组的插入。
        
    - t_ctid: 用来记录当前元组或者新元组的物理位置（块内偏移量和元组长度）
      
    - t_infomask2:用其低11位表示当前元组的属性个数
      
    - t_infomask: 标识当前元组的状态
      
    - t_hoff: 表示该元组头部的大小
      
    - _bits[]： 该数组用于标识该元组哪些字段为空
      
    - Postgresql中的“HOT技术“： postgresql中对于元组采用多版本技术存储，对元组的每个更新操作都会产生一个新版本，版本之间从老到新形成一条版本链（将旧版本的t_ctid字段指向下一个版本的位置即可）。但这一技术的问题就是浪费存储空间，旧版本占用的空间只有再进行VACUUM时才能被回收，增加了数据库的负担。为了解决这个问题，从版本 8.3开始，使用了HOT机制，当更新的元组同时满足如下条件时（通过HeapSatisfiesHOTUpdate函数判断），称为HOT元组：
      
      - 所有索引属性都没被修改
        
      - 更新的元组新版本与旧版本在同一文件块中
        
      
      HOT元组会被打上HEAP_ONLY_TUPLE标志，而HOT元组的上一版本则被打上HEAP_HOT_UPDATED标志。更新一条HOT元组将不会在索引中引入新版本，HOT技术消除了拥有完全相同键值的索引记录，减小了索引大小。
      
  - 在堆中删除一个元组，理论上的两种方法：
    
    - 直接物理删除：找到该元组所在文件块，并将其读取到缓冲区，然后在缓冲区删除这个元组，最后回写到磁盘中。
      
    - 标记删除：为每个元组使用额外的数据位作为删除标记。当删除元组的时，只需设置对应的删除标记，即可实现快速删除。这种方法并不立即回收删除元组占用的空间。（postgresql采用的是这种方法）
      
- 3.2.2 磁盘管理器
  
  - 磁盘管理器是SMGR的一种具体实现。它对外提供了管理磁盘介质的接口，其主要实现在文件md.c中。磁盘管理器并非对磁盘上的文件直接进行操作，而是通过VFD机制来进行文件操作。
    
  - 在postgresql中，凡是对存储在磁盘中的表进行磁盘操作，都是必须与磁盘管理器打交道，由它来统一处理。对文件的操作是通过磁盘文件描述符进行的，该结构为：
    
    ![](file://C:\Users\42180\AppData\Roaming\marktext\images\2022-04-19-19-52-00-image.png)
    
  - 注意：mdfd_chain 为空并不一定表示表仅有一段，可能其他段没有打开。对于一个大表的操作，往往是逐段打开的。在postgresql中，使用结构体<u>SmgrRelation来表示一个被打开的表文件</u>，该文件中保存了对表文件对应的MdfdVec链表的头部。<u>所有的SmgrRelation被组织成一个Hash表</u>，该hash表仅对后台进程可见，这样可以通过hash表快速找到表对应的MdfdVec链表。在md.c中提供了读写文件块的接口函数，其具体实现在文件fd.c中。<u>fd.c实现了VFD管理以及通过VFD执行对实际物理文件的操作。</u>
    
- 3.2.3 VFD机制
  
  
  - VFD实现原理
    
    由于操作系统的限制，一个进程能同时打开的文件的最大数目是有限制的，所以为了解决这个问题，Postgresql引入了VFD机制。VFD的机制原理类似于连接池，当进程申请打开一个文件时，总是能返回一个虚拟文件描述符，对外封装了打开物理文件的实际操作。所谓虚拟文件描述符，是指一个叫做VFD的数据结构 ，其中记录了操作系统为文件分配的真实的文件描述符。
    
    如果多个进程对同一个文件进行操作，那么每个进程都将获得一个真实文件描述符，而每个真实文件描述符又对应一个VFD，因此同一个文件对于不同进程而言，其VFD可能是不同的。
    
    
    -  在postgresql中，一个进程打开的VFD都是存储在VfdCache数组中，该数组的每个元素都表示该进程拥有的一个虚拟文件描述符，其数据类型为Vfd，其数据结构为：
      
      
      字段含义：
      
      - fd: 记录该VFD所对应的真实的文件描述符
        
      - fdstate: 表示该虚拟文件描述符的标记位
        
      - nextFree: 指向下一个空闲的VFD（在vfd数组中的下标）
        
      - lruMoreRecently: 指向比该VFD最近更常用的虚拟文件描述符
        
      - lruLessRecently: 最近不常用的
        
      - seekPos: 记录该VFD的当前读写指针的位置
        
      - fileName: 该VFD对应文件的文件名
        
      - fileFlags: 该文件打开时标志：只读只写等
        
      - fileMode: 文件创建时所指定的模式
        
  - LRU池
    
    每一个postgresql后台进程中都是用一个LRU池来管理所有已经打开的VFD，池中每个VFD都对应一个物理上已经打开的文件。每一个进程都拥有其私有的LRU池和一系列的VFD，进程需要打开文件时都是从自己私有的LRU池中申请VFD。
    
    - 当LRU池未满时，即进程打开的文件个数未超过系统限制时，进程可以照常申请一个VFD用来打开一个物理文件。当LRU池满时，进程首先利用LRU去关闭一个VFD，然后再去利用这个VFD去打开物理文件。
      
    - 进程在VfdCache上保持了两个链表，一个是LRU池（双向链表），另一个是FreeList(空闲链表，记录了所有可被分配的VFD)。
      
    - 当进程需要打开一个文件时，会为其分配一个VFD，而关闭文件时会回收VFD。VFD的分配和回收流程如下：
      
      - 进程在打开第一个文件时，将初始化VfdCache数组，置其大小为32，为每个Vfd结构分配空间，并将所有的数组元素放在FreeList上。
      - 当分配一个VFD的时候，即从FreeList头部取一个VFD，（同时需要检查LR u池是否已满，也就是检查当前进程所打开的物理文件个数是否已经达到了操作系统的限制，如果没有超过限制，进程就可以使用该VFD打开物理文件并将其插入到LRU池中；否则就需要用到LRU算法取替换LRU池中的VFD）并打开该文件，将该文件的相关信息记录在分配的VFD中。
      - 如果FreeList上没有空闲的VFD，就将VfdCache数组扩大一倍，新增加的VFD放入FreeList链表中。
      - 关闭文件时，将该文件所对应的VFD插入到FreeList头部。
    - Postgresql将一个进程中正打开（为该文件分配了真实的文件描述符）的所有的VFD都链成一个环，即LRU池。
      
      
      - VfdCache数组中的每个元素都代表一个VFD，方框中的符号表示该VFD在数组中的下标。
        
      - VfdCache[0]充当了LRU链表头部的作用，它永远不会被实际分配给任何文件。
        
      - 显然，LRU池的大小与操作系统对于进程打开文件数的限制是一致的，在Postgresql的实现中用全局变量max_safe_fds来记录该限数。
        
      - 对LRU池的操作：
        
        - 从LRU池中删除VFD：该操作发生在进程使用完一个文件并关闭它时，通过LruDelete函数实现，该操作将指定的VFD从LRU池中删除，并将该VFD对应的文件关闭掉。这样这个VFD就变为空闲，还需要将其加入到空闲链表中。
          
        - 将VFD插入到LRU池中：利用头插法，插入到VFD[0]的后面。该操作发生在打开一个新的VFD时，通过LruInsert函数实现。
          
        - 删除LRU池尾的VFD：ReleaseLruFile函数实现，将LRU末尾的哪个VFD删除，当LRU池满的时候，而此时又要打开新的文件的时候，需要执行这个操作。
          
- ３.２.４　空闲空间映射表(FSM - free space map)
  
  随着表中不断插入和删除元组，文件块中必然会产生空闲空间（free space）。在插入元组时优先选择将其存放在空闲空间内是利用存储的好方法，但是这需要在该表拥有的多块拥有空闲空间的文件块中选择。
  
  postgresql8.4的策略：对每个表文件都同时创建一个名为”关系表OID_fsm“的文件，用于记录该表的空闲空间大小，称为：空闲空间映射表文件（FSM）。例如一个OID为12000的表，其空闲空间映射表文件将被命名为12000_fsm.
  
  - 一个表文件对应一个FSM；一个表文件对应多个块（表块），同理，一个FSM也对应多个块（FSM块）。
    
  - 对于一个表的所有表块，无论是否有空闲空间，在FSM文件中都能找到对应的字节。
    
  - 若一个表块中存在空闲空间，就将其空闲空间字节映射为一个整数，在FSM中用1字节记录；若表中没有空闲空间，在FSM中使用0值来对应记录。对于任何一个表块，只要找到它在FSM文件中对应的字节，根据该字节的值就可以知道这个标快中空闲空间的大小是多少。
    
    
  - 为了实现快速查找，FSM文件中并不是简单的使用数组顺序存储每个表块的空闲空间，而是使用了树结构。
    
  - 总结：比如一个表文件有m个块，也就是有m个块文件（每个块文件中前32个字节不可使用，当申请空间大小在8164-8192的时候，系统分配MaxHeapSize的空闲空间，也就是一整个块空间）；对于FSM文件，也可以分成很多块，其中存储的为（表块号，此表块剩余空闲空间的大小的tag[上上图中的标志]），为了加速空闲块的查找，对FSM文件结构进行优化，利用树结构。树结构原理：分成三层：0层、1层为辅助层，2层位实际存放各表块的的空闲空间值。第2层FSM块中大根堆的每一个叶子表示一个表块的空闲空间值；按照从左到右的顺序，最左边的FSM块中左边第一个叶子节点对应表文件的第一块，左边第二个叶子对应表文件的第二块，以此类推。
    
    
  - 对FSM文件的操作：
    
    - 1、创建FSM
      
    - 2、查找FSM
      
    - 3、调整FSM
      
- ３.２.５　可见性映射表（VM　－　Visibiliy-Map）
  
  Postgresql中为了实现多版本并发控制，当事务删除或更新元组的时候，并非从物理上删除，而是通过将其标记为无效的方式进行标记删除，最终对这些无效元组的清理操作需要调用VACUUM来完成。
  
  - 为了加快VACUUM查找包含无效元组的文件块的过程，在Postgresql8.4.1中为每个表文件定义了一个新的附属文件-可见性映射表（VM）。VM为表的每个文件块设置了一位，用来标记该文件块是否存在无效元组。
    
  
  - 对于包含无效元组的文件块，VACUUM有两种方式处理，`快速清理（Lazy VACUUM）` 和 `完全清理（Full VACUUM）` 。注意，VM文件仅在Lazy VACUUM操作中被使用到，而Full VACUUM操作由于要执行跨块清理等复杂操作，需要对整个表文件进行扫描，这时候VM文件作用不大。
    
  - 对于每个表文件，其对应的VM文件命名为：”关系表OID_vm“.对该文件的操作在visibility-map.c中。
    
  - VM文件也被分为若干个块（VM块）。VM块中除了必要的标记信息外，其他的每一位都对应一个表块，当表块中的所有的元组对当前的事务都是可见的时候，表块对应的位才设置为1.
    
    
  - 当对某个表块中的元组进行更新或者删除后，那么该表块在VM文件中对应位置的标志位将被置为0.（在设置标志位的时候，需要对其对应的VM页面加锁，为了避免在VACUUM判断此页面对所有事务是否可见的时候，其他进程修改了此页面，从而导致VACUMM清理过程中忽略了此页面）。
    
  - 注意：当前，VM文件仅仅是作为一个提示hint来加快VACUUM的速度，所以即使VM文件损坏，也仅仅会导致VACUUM忽略那些需要清理的页面，而不会对数据产生任何负面影响。
    
- ３.２.６　大数据存储
  
  在Postgresql中提供了两种大数据存储方式：
  
  - TOAST机制，使用数据压缩和线外存储来实现
    
  - 大对象机制，使用一个专门的系统表来存储大对象数据
    
- 3.3 内存管理
  
  不管什么样的数据库管理系统，其存储管理中设计的问题本质是一样的：如何减少IO次数。在通常情况下，读写磁盘所用的时间决定了数据库操作所花费的总时间。因此，要尽可能的让最近使用的文件块停留在内存中，



> 参考文献
- 《PostgreSQL数据库内核分析》

